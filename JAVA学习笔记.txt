java中的命名规范：
包名：一般包名由多个单词组成的时候我们使用全小写；
类名或者接口名：由多个单词组成的时候所有单词的首字母都使用大写
变量名和方法名：多单词组成时，第一个首字母小写，第二个大写；
常量名：每个字母都大写，并且单词之间用下划线连接起来；

成员变量在内存中是堆内存；随着对象的存在而存在，消失而消失；有默认的初始化值；
局部变量在内存中是栈内存；随着方法的调用而存在，消失而消失；没有默认的初始值；
静态变量和成员变量：
静态变量属于类，称之为类变量；存储于静态区；随着类的加载而加载；类名和对象名都可以调动；
成员变量属于对象，称之为实例变量；存储于对内存；随着对象的创建而存在；只能通过对象名调用；

静态：
静态是属于类的，不属于某个对象；
静态变量可以实现数据共享，即是所有所有的对象的对应变量永远都是一样的。
优先于对象的产生
静态的内容最好是要用类名去访问。

对象的创建过程：
1.静态构造器
2.通用构造器
3.构造方法
由于创建对象的过是在静态内容加载完成过后，所以静态方法和静态块里不能使用this关键字（也就是说不能访问对象）。

包的本质是文件夹；
不同的包里的类的使用是需要导包的；
java.lang包下的所有内容都不需要导包。（string和system.out.println()）；

访问权限
private关键字：
是一个权限修饰符，可以修饰成员变量和成员方法；被private修饰的成员只在本类中才能访问；
当成员变量被私有化的时候，用getxxx（）函数或者setxxx（）函数就可获取以及赋值；idea中有相应的generate。

this关键字：
表示所在类的对象引用；方法被哪个对象调用，this就代表那个对象；局部变量隐藏成员变量时用（如果想要在局部变量中和成员变量冲突了，调用成员你变量就用this）；

构造方法：
在创建对象的时候就自动调用的方法。
格式：方法名同类名；没有返回值，连void都没有；可以重载；
注意：没有返回值；
在我们使用new的时候会自动调用；
重载：指函数一样但是传递的参数不一样个数或者参数的顺序，这样的两个方法叫做方法的重载。
重载的构造方法可以用this去访问另外一个构造方法。this（）；

static关键字：
可以修饰成员变量和成员方法；随着类的存在而存在，优于对象存在，被类的所有对象共享；既可以通过对象名调用，也可以通过类名调用，建议类名调用；
在静态方法中没有this关键字；静态方法只能访问静态的成员变量和静态的方法；（为什么主方法是静态的还可以调用某些非静态成员？因为在自己的函数体内床架动态的变量，动态是可以调用静态的，对象是属于动态的）

getter和setter：
用于私有变量的赋值和访问；

继承：
子类可以继承父类中的公用的方法；但是不能继承父类中的任何私有的方法；简化代码，子类对父类进行了扩展。
子类中的this关键字的使用：先找自己类的属性中是否含有这个变量，没有则再找父类属性中是否含有这个变量；

super关键字：
表示父类中的内容，可以用super和this来区分子类和父类的重复内容；
构造方法的调用，首先是先调用子类的构造方法，但是在子类的构造方法中的第一行就会调用super（），类似this（）；即是父类的构造方法；
可以调用父类中的构造方法，必须写在子类构造方法中的第一行，如果父类的构造是无参数的可以不写，如果父类的构造中是有参数的，那么在子类中必须要写super，并且将参数传递过去；

方法的重写：
语法：子类的方法名和父类的方法的声明必须是一样的。
如果想在子类中调用父类中被重写的方法，就可以用super去调用（半盖）

多态：
同一个对象拥有多种形态；
把不同的数据类型进行统一；
1.把子类的对象赋值给父类的变量叫做向上转型；会屏蔽掉子类中的特有的方法；
2.把父类的变量转化为子类的变量叫做向下转型；（向下转型有风险，我们需要运用强制转换）；

final关键字：
被final修饰的变量是不可以改变的；
被final修饰的方法不能被重写；
被final修饰的类不能被继承；

抽象：用abstract来声明
只声明，不实现；
修饰方法，则方法没有方法体；一旦有抽象方法则该类必须为抽象类；
抽象类不能实例化；
抽象类的子类必须重写父类中的抽象方法；（因为继承了父类中的抽象方法，只有重写才能让子类不为抽象类）
通过抽象类必须要求子类中必须有哪些方法；
抽象类中可以有正常的方法；

接口：
接口是一种特殊的抽象类
接口中的所有方法都是抽象方法
接口使用interface来声明
接口中所有的内容都是公开的，即使不写公共修饰，也是一样的。
能让你和继承接口的只能是接口；
接口和类只能是实现关系（不能写extends，而是用implements ）；然后一定要重写里面的接口里面的方法（不然就继承了抽象方法，那么类就会变成抽象类）；
接口同样具有多态性；
类只能单继承。而接口支持多实现；
接口可以把很多的不相关的内容进行整合；
接口中所有的变量都是全局静态变量；

成员变量：
java中所有变量必须先声明后赋值才能使用；
java中的成员变量，在创建对象的时候都会执行一次初始化操作，都会给一个默认值；（基本数据类型时0，引用数据类型时null）

toStirng():
对一个对象的字符串的表示形式；
打印一个对象的时候要用系统的重写方法才能打印出具体的内容，不然的话打印出来的就是一段字符串；

instanceof关键字：
判断某个对象是某个对象；

内存分析：
堆用于存放对象；
栈用于存放局部变量以及基本数据类型；
代码区：类和方法；
数据区：常量池和静态变量；
值传递：把变量的值作为参数进行传递；
引用传递：直接把变量作为参数进行传递
java使用的是值传递；

封装的原则：
将不需要对外提供的属性隐藏，提供公共方法对其访问；


异常： 
编译型异常：
运行时异常（runtimeexception）：
error：系统级错误；
异常处理：
可以try{}catch{}finally{};也可以直接方法中throws Exception，还可以再次抛出错误，只要有人调用这个方法就要有人处理这个方法；
throws：表示可能向外抛出异常；
throw：表示向外抛出一个异常的操作；throw new Excrption("");
自定义异常：
可以直接继承Exception或者RuntimeExceptio来实现自定义异常；

常用API：
基本数据类型时没有面向对象的特征的，也就是不会继承object类；
所以基本类型可以包装成包装类。

IO流：
节点流：直接连接在文件上的；
处理流：套在其他流上面；
包括：
缓冲流：套在节点流上
转换流：将字节流转换为字符流（InputOutStreamReader和OutputStreamWriter两个方法）
有时候流不可以关，比如system.out不能关；
对象流：(报错：NotSerializableException)先要把一个对象转化为一个字节的过程叫做序列化（java中只需要给类添加一个实现，Serialiable；然后用objectoutstream

字符流：用于读取文件中的文字信息；
字节流：用于读取一些非字符串，如音频，图片信息；
当输出流发现你的输出文件不存在时，会帮你创建这么一个文件

文件修改：

操作系统：
本质是运行在一对硬件上的巨型软件；帮助上层应用程序屏蔽掉硬件的丑陋的接口
进程：正在执行的程序。就是一块内存区域，内部存储这程序的资源
线程：程序被CPU调度的最小单位，

java多线程：
1.继承thread类，重写run方法；
2.实现runable接口，实现run方法(里面只有一个方法，即是run方法)
必须start（），以及run（）；
start（）:启动一个线程；

线程中的相关操作：
setPriority()设置优先级；
Sleep()睡眠，让一个线程暂停一段时间；
join():让主线程等待子线程跑完；(当主线程的任务比子线程先跑完的时候用)
yield():让出CPU，让别人先运行一下，但不代表绝对放弃。
interrupt()：打断线程；

线程同步：
当多个线程共享一个资源的时候，我们可以在一个线程访问到这个资源的时候，把这个资源暂时封锁，等待执行结束，释放这个锁，其他线程才可以进行执行。
1.再方法声明上加上synchronized（一旦进入该方法，瞬间锁定这个资源）
2.在方法内部使用synchronized(){}语句块对特定的对象上锁
3.手动上锁
StringBuilder没有上锁，线程不安全，而StringBuffer线程安全（不想别人访问时yong)
死锁：尽量不要将互相调用的方法锁定

生产者消费者模型：
Queue队列：BlockingDeque一个阻塞队列，当队列中没有数据的时候，队列会阻塞阻塞到队列中有数据为止。
Atomiclnteger线程安全数字

链路层：
Mac：每台计算机的唯一的确定的物理地址，被写在了网卡上（12位16进制的数字组成，前六位是厂商编号，后六位是流水号）
网络层：
ip地址：每台计算机有唯一的ip地址，用来划分子网，子网掩码；
子网掩码：

传输层：
端口：网卡和应用程序绑定
tcp协议：可靠的传输；但是速度慢；
udp协议：不可靠传输；但是速度快；

应用层：

软件架构：
CS架构：客户端程序
优势：把一部分计算留在客户端进行，缓解服务器压力;
劣势：如果游戏或者软件升级，客户端那必须进行手动更新;
BS架构：
网页浏览器服务器架构;
京东，淘宝等
优势:维护成本低;
劣势:没办法在客户端做大量计算;


客户端：可以给服务器发送数据的软件，可以接受服务器发送过来的消息；
服务器，负责接受客户端发送的消息，处理数据，给客户端相应;

Tcp编程：





快捷键：
Ctrl+Alt+/:             文字补全；
Ctrl+/或者Ctrl+7:   行注释；
Ctrl+shift+/:     块注释；
Ctrl+shift+\:     取消块注释；
Ctrl +1：   快速修正；
Ctrl +I:自动更正缩进；

快捷键
C+F:  查找
C+R:  替换
C+D:  复制行到下一列
C+X:  剪切
C++:  展开代码
C+-:  折叠代码
C+/:  注释所在行
C+[:  移动到花括号最前面
C+]:  移动到花括号最后
C+F1:  显示错误代码的详细信息
C+F8:  打断点或者取消断点
C+enter：  只能分隔行
C+左右、前后：到达该单词的的左端、相当于滑轮；

shift+F8:  在debug模式下，跳出；
shift+F9:  等效于debug；
shift+F10：run；
alt+上：向上移动；

文件名同类名；

jdk: java开发工具包；
jre:java运行环境；
jvm：java虚拟机；


基本数据类型：
int 整型 4个字节
double 双精度浮点类型 8个字节
float 单精度浮点类型 4个字节
char  字符类型 2个字节
boolean 布尔类型 1个字节

一 、数值型
1.整数类型（byte-8位、short-16位、int-32位、long-64位）
整数类型有八进制，二进制，十六进制，八进制以0作为开头，十六进制以0x开头
例：intx;  //定义int型变量x   
       intx,y;  //定义int行变量x、y   
       intx=450,y=65;  //定义int型变量x、y并赋予给初值
注意：对于long型值，若赋予的值大于int型的最大值或者小于int型的最小值就需要在数字后面加上一个L或者l

2.浮点类型（float-32位单精度、double-64位双精度）
一般情况下小数被看作double类型，若使用float类型小数则需要在小数后面添加F或f,如果不加就默认为double类型。
例：float f1=13.23f;
      double d1=4562.12d;
      double d2=45678.124;

二、字符型（char型、转义型）
1.char类型
字符类型用于储存单个字符，占用16位（两个字节）的空间。
's'表示一个字符，"s"表示一个字符串
char x='a';   因为a在unicode表中的排序位置是97，所以允许写成  char x=97;
JAVA可把字符当整数对待

2.转义字符
以“\”开头，后跟多个字符用于改变字符原有意义，故称转义字符
例：\ddd : 1-3位八进制所表示的字符，如\123
      \uxxxx: 4位十六进制数据表示的字符，如\u0052
      \'  : 单引号字符 
      \\  :反斜杠字符
      \r  ：回车
      \b  :退格
将转义字符赋值给字符变量时，与字符变量一样需要使用单引号
例  char c1='\\';   //将转义字符赋值给变量c1

三、布尔类型（逻辑类型）
boolean b;
boolean b1,b2;
boolean b=true;

标识符与关键字：
1.标识符
用来标识类名，变量名，方法名，数组名，文件名的有效字符序列
标识符有任意顺序的字母，下划线，美元符号，和数字组成并且第一个字符不能是数字，标识符不能是java中的保留关键字
2.关键字
int public this finally boolean 等

声明变量：
变量名必须是合法的标识符，变量名不可以是JAVA中的关键字，变量名不能重复，应选择 有意义的单词做变量名（也可使用其他语言的文字作为变量名）
例 int age;
     char char1=‘a’;

声明常量：
运行程序中一直不改变的量叫做常量，常量在整个程序中只能被赋值一次。当定义的final变量属于成员变量是，必须在定义是就设定他的初值，否则将会产生编译错误
声明标准语法为：final 数据类型 常量名称 [=值]
常量名常用大写字母表示，但是不是必须的。
例 final double PI=3.1415926D;
    final boolean BOOL=true;


变量的有效范围：
1.成员变量
实例变量：int x=45;
静态变量：static int y=90;(即在实例变量的数据类型前加关键字的成员变量称为静态变量）
2.局部变量
在方法内部定义的，方括号之间的代码中声明的变量称为局部变量。在类方法中声明的变量，包括方法的参数都属于局部变量。
如果此时成员变量的名字和局部变量的名字相同时就会隐藏成员变量

运算符：
1.赋值运算符：
左方必须是一个变量，右边的操作数可以是任何表达式，包括变量（a,number）,常量（123、'book'）有效的表达式（45*12）
 根据运算规则，会优先处理右边表达式，若一个表达式中有两个以上的“=”，会从最右边的开始处理
例：int a=a,b,c;
a=15;
c=b=a+4;
JAVA中可将运算符连载一起用：X=Y=Z=45;
 

2.算数运算符：
主要由+、-、*、/、%（求余）在进行除法运算是0不可以作为除数


3.自增自减运算符：
自增自减运算符是单目运算，可以放在操作元之前，也可以放在操作元之后，操作元必须是整数或者浮点类型
自增自减运算符的作用是是变量的值增1或减1然后再使该变量参与表达式的运算，放在操作元之后的自增自减运算符会使变量先参加表达式的运算再将该变量加1或减1
例：++a    //表示在使用变量前对a进行先加1
       --a     //表示在使用变量a之后再对a进行加1（a必须是整数或者浮点类型）
例： b=++a,  当a=4时，b=5  ，a=5;
        b=a++,  当a=4时，b=4 ,   a=5;
自增自减运算符只能操作变量不能操作常量或者数值；

4.比较运算符：
比较运算符时二元运算符，用于程序间的变量之间以及其他类型信息之间的比较，比较运算符的运算结果是布尔类型，当运算关成立时运算结果为true;
比较运算符有：>.<,==,>=,<=,!=(用于比较左边是否不等于右边)
例：‘y  != 't’
  

5.逻辑运算符：
【逻辑运算符的操作元必须是布尔类型；】逻辑运算符包括：&（&&）（逻辑与）、||（逻辑或）、！（逻辑非）

6.位运算符：
按位与（&）：只有两个数据对应位都是1结果才是1；否则为0；如果两个数据的操作精度不同，则结果的精度与精度高德操作数相同；

按位或（|）：只有两个数据对应位都是0结果才是0；否则为1；如果两个数据的操作精度不同，则结果的精度与精度高德操作数相同；

按位取反（~）：将每位的0和1互换；

按位异或（^）：两个数据的每一位相同则为0；否则为1；如果两个数据的操作精度不同，则结果的精度与精度高德操作数相同；

移位操作：<<(左移）：【就是将运算符左边的操作数的二进制数据，按照运算符右边操作数的指定位数向左移动，右边移空的部分补0】
	>>（右移）：【如果最高位是0，右移空位就填入0；如果最高位是1，右移空位就填入1】
	>>>（无符号右移）：【无论最高位是0还是1，左侧被移空的高位都填入0】
注意：移位运算符适用的数据类型只有整型数据和字符型数据（byte,short ,char,int,long ）；
移位可以实现整数除以或者乘以2的n次方的效果：
	例如：y<<2与y*4结果相同；
	          y>>1的结果与y/2的结果相同；
		总之，一个数左移n位，就是将这个数乘以2的n次方，一个数右移n位，就是将这个数除以2的n次方；

7.三元运算符：
格式：条件式？值1：值2
运算规则：若条件式的值为true，则整个表达式取值1，否则取值2；例如：boolean b =20<25?true:false;
三元运算符等价于if...else语句；

运算符的优先级：【相同优先级则从左到右结合】
由高到低：增量和减量运算>算术运算>比较运算>逻辑运算>赋值运算
括号>正负号>一元运算符（++，--，！） >乘除>加减>移位运算（>>,<<,>>>）>比较大小>比较是否相等（==，！=）
>按位与(&）>按位异或（^）>按位或（|）>逻辑与（&&）>逻辑或（||）>三元运算符（？：）>赋值预算符（=）；

四、数据类型转换
隐式类型转换：低级 转换为高级；
byte<short<int<long<float<double（char在short和int之间）；

显示类型转换（强制类型转换）
（类型名）要转换的值；
【除了boolean类型外其他的基本类型都能够以显示类型的方法进行转换】

五、语句
1. 复合语句：复合语句中定义的变量作用范围只能是在该语句中；

2. 条件语句：
2.1 、if条件语句：if（布尔条件表达式）{语句序列}；后面的语句序列省略时，可以省略后面的大括号或者不省；
2.2 、if...else语句：if或者else后面的语句序列可以是空；
2.3.、 switch语句：case后面的常量表达式可以是整数但是不能是实数；

3. 循环语句：
3.1 、while语句：
3.2 、do...while 语句：
3.3、for语句：
3.4、foreach语句：for（元素变量x；遍历对象obj）{引用了x的java语句}；

4.break语句：break语句跳出多层循环的外循环：标签功能
标签名：循环体{break 标签名}；（标签名须是相同；标签名是任意的标识符；）

5.continue语句：continue语句跳出多层循环的外循环：标签功能
标签名：循环体{break 标签名}；（标签名须是相同；标签名是任意的标识符；）

switch语句的表达式可以是整型、字符型、或者是字符串类型。

java中一句相连字符创不能分开在两行中写，可以使用加号将字符串连接起来。

Java中所有不正常类都继承于Throwable;(是所有不正常类的父类）
异常分为error异常和exception异常；
error异常是系统异常；
exception异常分为非检查异常和检查异常；
非检查异常（runtimeerror）包括：空指针异常和数组下标越界异常和类型转换异常以及算术异常；
检查异常包括：文件不存在或者链接异常；




字符串的一些基本操作：
1.创建字符串：
String s1="isfah";
String s2=new String();
String s3=new Sting("faskj");
String s= new String(a):a是一个字符数组的名称；
String s=new String(a,0,4):从字符数组中前面参数位置到后面参数位置的字符构成一个字符串；

获取字符串长度
str.length():

字符串查找：
字符串中首次出现一个字符或者字符串对象：
str. indexOf(c或者str)；
字符串中最后一次出现一个字符或者字符串对象：
str.lastIndexOf(c或者str);

获取指定索引位置的字符：
str.charAt(int )：将字符串中参数位置的字符返回

字符串操作
获取子字符串：
str.substring(int startindex,int endindex):从字符串中参数1位置到参数2的位置截取，如果只有一个参数就认为到字符串结束；

去除空格：
str.trim():去掉字符串对象str的前导空格和后导空格；

字符串替换：
str.replace(old char c,new char c1)：将字符串str中的旧的字符（区分大小写）替换为新的字符；如果老字符串中的参数字符有很多将会全部被替换

判断字符串是否相等：
str.equals(str1):判断两个字符串是否相等，是则返回true否则返回false；
str.equalsIgnoreCase(str1):此方法对字符串大小的比较是忽略了字符的大小写的，相当于"abc".equalsIgnoreCase("ABC"）=true；

按字典顺序比较两个字符串大小：
str.compareTo(str1):如果str字符串比参数字符串大则返回正整数；否则返回负整数；如果相等就返回0；

字母大小写转换：
str.toLowerCase():将字符串全部转换为小写；
str.toUpperCase()：将字符串全部转换为大写；

字符串分隔：
str.split(“<分隔符>”，次数):分隔符可以是多个（“+=”），次数将决定分隔次数； 【注意：当分隔符是一些特殊符号的时候，因为是正则表达式，特殊符号的位置被占用，只能通过转义字符去表示特殊符号字符，‘\\.’】
String []s1=str.split("\\.")

集合框架：
由collect接口和map接口组成；
collect接口（有三个常用的子接口）：
LIst：有一个很重要的实现类叫做ArrayList、LinkedList实现类；
list接口里面的元素是有序并且是可以重复的，所以我们称之为序列；
可以精确的增加或者移除某个具体的元素；
Queue:实现类LinkedList实现类；
Set:HashSet（哈希集）实现类；
Set是元素无序并且不可以重复的集合，被称之为集；

Map接口（）：是一个键值对，支持泛型
HashMap实现类：里面的Entry对象是无序排列的，key和value都可以是null，但是HashMap中只能有一个key值为null的映射（key不可以重复）;

















